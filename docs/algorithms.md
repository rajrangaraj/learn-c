# ùêÄùê•ùê†ùê®ùê´ùê¢ùê≠ùê°ùê¶ùê¨ ùê¢ùêß ùêÇ
## Algorithm Basics
- **Algorithm definition**: Step-by-step procedure for solving a problem
- **Algorithm properties**: Finiteness, definiteness, input, output, effectiveness
- **Algorithm design**: Problem analysis, solution planning, implementation approach
- **Algorithm verification**: Testing, debugging, correctness proofs
- **Algorithm documentation**: Pseudocode, flowcharts, comments

## Data Structures
- **Arrays**: Fixed-size sequential collection of elements
- **Linked Lists**: Dynamic sequence of elements connected via pointers
- **Stacks**: LIFO data structure for temporary storage
- **Queues**: FIFO data structure for ordered processing
- **Trees**: Hierarchical structure with parent-child relationships

## Algorithm Categories
- **Iterative algorithms**: Use loops to repeat operations
- **Recursive algorithms**: Functions that call themselves
- **Greedy algorithms**: Make locally optimal choices
- **Divide and conquer**: Break problem into smaller subproblems
- **Dynamic programming**: Solve complex problems by breaking into simpler subproblems

## **Algorithm Efficiency**
- **Time efficiency**: How running time increases with input size
- **Space efficiency**: How memory usage increases with input size 
- **Best case**: Performance under optimal conditions
- **Average case**: Expected performance under normal conditions
- **Worst case**: Performance under most unfavorable conditions

## Sorting Algorithms
- **Bubble sort**: Simple algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if in wrong order
- **Selection sort**: Divides input into sorted and unsorted regions, repeatedly selects smallest element from unsorted region
- **Insertion sort**: Builds final sorted array one item at a time, by repeatedly inserting a new element into the sorted portion
- **Quick sort**: Efficient divide-and-conquer algorithm that partitions array around pivot element
- **Merge sort**: Divide-and-conquer algorithm that recursively divides array in half and merges sorted subarrays

## Searching Algorithms
- **Linear search**: Simple search that checks each element sequentially until match is found
- **Binary search**: Efficient algorithm for sorted arrays that repeatedly divides search interval in half
- **Hash-based search**: Uses hash function to map keys to array indices for O(1) average case lookup
- **Tree-based search**: Searches hierarchical tree structures like binary search trees
- **Pattern matching**: Algorithms for finding occurrences of patterns within larger sequences
## **Advanced Algorithms**
- **Backtracking**: Systematic method to find solution by exploring all possibilities
- **Branch and bound**: Optimization technique that systematically eliminates poor solutions
- **Genetic algorithms**: Nature-inspired algorithms that use concepts of natural selection
- **Neural networks**: Algorithms inspired by biological neural networks
- **Probabilistic algorithms**: Algorithms that use random choices in their logic

## Graph Algorithms
- **Graph representation**: Ways to store graph structure (adjacency matrix, adjacency list, etc.)
- **DFS and BFS**: Depth-first and breadth-first graph traversal strategies
- **Shortest path**: Algorithms like Dijkstra's and Bellman-Ford for finding shortest paths between nodes
- **Minimum spanning tree**: Algorithms like Prim's and Kruskal's for finding minimum-weight tree connecting all nodes
- **Topological sort**: Linear ordering of directed acyclic graph vertices based on dependencies

## **String Algorithms**
- **Pattern matching**: Algorithms like KMP and Boyer-Moore for finding string patterns
- **String manipulation**: Operations for modifying and transforming strings
- **Parsing**: Techniques for analyzing and processing structured text
- **Compression**: Algorithms for reducing string storage size like Huffman coding
- **Encryption**: Methods for encoding strings to protect confidentiality

## **Algorithm Analysis**
- **Time complexity**: Analysis of algorithm running time as input size grows
- **Space complexity**: Analysis of memory usage as input size grows
- **Big O notation**: Mathematical notation describing upper bound of growth rate
- **Algorithm optimization**: Techniques for improving algorithm efficiency
- **Performance testing**: Methods for measuring and comparing algorithm performance